<!DOCTYPE html>
<html>
<head>
<title>README</title>

<style>
        .copy {
            max-width: 700px; font-family: sans-serif; margin: 0 auto; line-height: 1.5;
        }
        pre {
            background-color: #eee;
            padding: 1em;
            padding-top: 0;
            overflow: auto;
        }
        table {
            border-collapse: collapse;
            width: 100%;
        }
        table+table {
            margin-top: 2em;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 0.5em;
            vertical-align: top;
        }
        td:first-child {
            width: 170px;
        }
        td code {
            white-space: nowrap;
        }
        samp {
            color: rgb(110, 110, 110);
        }
</style>
</head>
<body>
<div class="copy">
<h1>README</h1>
<p>This codebase has been generated by <a href="https://autostrada.dev/">Autostrada</a>.</p>
<h2>Getting started</h2>
<p>Make sure that you're in the root of the project directory and run the <code>cmd/api</code> application using <code>go run</code>:</p>
<pre><code>
$ go run ./cmd/api
</code></pre>
<p>If you make a request to the <code>GET /status</code> endpoint using <code>curl</code> you should get a response like this:</p>
<pre><code>
$ curl -i localhost:4444/status
<samp>HTTP/1.1 200 OK
Content-Type: application/json
Date: Mon, 09 May 2022 20:46:37 GMT
Content-Length: 23

{
    "Status": "OK",
}</samp></code></pre>
<h2>Project structure</h2>
<p>Everything in the codebase is designed to be editable. Feel free to change and adapt it to meet your needs.</p>
<table>
<tbody>
<tr>
<td><strong><code>cmd/api</code></strong></td>
<td>Your application-specific code (handlers, routing, middleware, helpers) for dealing with HTTP requests and responses.</td>
</tr>
<tr>
<td><code>↳ cmd/api/errors.go</code></td>
<td>Contains helpers for managing and responding to error conditions.</td>
</tr>
<tr>
<td><code>↳ cmd/api/handlers.go</code></td>
<td>Contains your application HTTP handlers.</td>
</tr>
<tr>
<td><code>↳ cmd/api/main.go</code></td>
<td>The entry point for the application. Responsible for parsing configuration settings initializing dependencies and running the server. Start here when you're looking through the code.</td>
</tr>
<tr>
<td><code>↳ cmd/api/middleware.go</code></td>
<td>Contains your application middleware.</td>
</tr>
<tr>
<td><code>↳ cmd/api/routes.go</code></td>
<td>Contains your application route mappings.</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td><strong><code>internal</code></strong></td>
<td>Contains various helper packages used by the application.</td>
</tr>
<tr>
<td><code>↳ internal/leveledlog/</code></td>
<td>Contains a leveled logger implementation.</td>
</tr>
<tr>
<td><code>↳ internal/request/</code></td>
<td>Contains helper functions for decoding JSON requests.</td>
</tr>
<tr>
<td><code>↳ internal/response/</code></td>
<td>Contains helper functions for sending JSON responses.</td>
</tr>
<tr>
<td><code>↳ internal/server/</code></td>
<td>Contains a helper function for starting and gracefully shutting down the server.</td>
</tr>
<tr>
<td><code>↳ internal/validator/</code></td>
<td>Contains validation helpers.</td>
</tr>
<tr>
<td><code>↳ internal/version/</code></td>
<td>Contains the application version number definition.</td>
</tr>
</tbody>
</table>
<h2>Configuration settings</h2>
<p>Configuration settings are managed via command-line flags in <code>main.go</code>.</p>
<p>You can try this out by using the <code>-addr</code> flag to configure the network address that the server is listening:</p>
<pre><code>
$ go run ./cmd/api --addr=:9999
</code></pre>
<p>Feel free to adapt the <code>main()</code> function to parse additional command-line flags and store their values in the <code>config</code> struct. For example, to add a configuration setting to enable a 'debug mode' in your application you could do this:</p>
<pre><code>
type config struct {
    addr string
    debug bool
}

...

func main() {
    var cfg config

    flag.StringVar(&amp;cfg.addr, "addr", ":4444", "server address")
    flag.BoolVar(&amp;cfg.debug, "debug", false, "enable debug mode")

    flag.Parse()

    ...
}
</code></pre>
<p>If you don't want to use command-line flags for configuration that's fine. Feel free to adapt the code so that the <code>config</code> struct is populated from environment variables or a settings file instead.</p>
<h2>Creating new handlers</h2>
<p>Handlers are defined as <code>http.HandlerFunc</code> methods on the <code>application</code> struct. They take the pattern:</p>
<pre><code>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    // Your handler logic...
}
</code></pre>
<p>Handlers are defined in the <code>cmd/api/handlers.go</code> file. For small applications, it's fine for all handlers to live in this file. For larger applications (10+ handlers) you may wish to break them out into separate files.</p>
<h2>Handler dependencies</h2>
<p>Any dependencies that your handlers have should be initialized in the <code>main()</code> function <code>cmd/api/main.go</code> and added to the <code>application</code> struct. All of your handlers, helpers and middleware that are defined as methods on <code>application</code> will then have access to them.</p>
<p>You can see an example of this in the <code>cmd/api/main.go</code> file where we initialize a new <code>logger</code> instance and add it to the <code>application</code> struct.</p>
<h2>Creating new routes</h2>
<p><a href="https://github.com/julienschmidt/httprouter">HttpRouter</a> is used for routing, but it's fine to swap to a different router if you want.</p>
<p>Routes are defined in the <code>routes()</code> method in the <code>cmd/api/routes.go</code> file. For example:</p>
<pre><code>
func (app *application) routes() http.Handler {
    mux := httprouter.New()
    
    mux.HandlerFunc("GET", "/your/path", app.yourHandler)
    
    return mux
}
</code></pre>
<p>For more information about HttpRouter and example usage, please see the <a href="https://github.com/julienschmidt/httprouter">official documentation</a>.</p>
<h2>Adding middleware</h2>
<p>Middleware is defined as methods on the <code>application</code> struct in the <code>cmd/api/middleware.go</code> file. Feel free to add your own. They take the pattern:</p>
<pre><code>
func (app *application) yourMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Your middleware logic...
        next.ServeHTTP(w, r)
    })
}
</code></pre>
<p>You can then use this middleware by wrapping the router before returning it from the <code>routes()</code> method, like so:</p>
<pre><code>
func (app *application) routes() http.Handler {
    mux := httprouter.New()
    
    mux.HandlerFunc("GET", "/your/path", app.yourHandler)
    
    // Wrap the router with middleware.
    return app.yourMiddlware(app.yourOtherMiddleware(mux))
}
</code></pre>
<p>It's possible to use middleware on specific routes only:</p>
<pre><code>
func (app *application) routes() http.Handler {
    mux := httprouter.New()
    
    mux.HandlerFunc("GET", "/your/path", app.yourHandler)

    // Wrap this handler with route-specific middleware. Note that when 
    // wrapping handler functions with route-specific middleware that you
    // need to convert them to a http.Handler by using the http.HandlerFunc()
    // adapter. Like so: 
    mux.Handler("GET", "/your/other/path", app.yourOtherMiddleware(http.HandlerFunc(app.yourOtherHandler)))
    
    return app.yourMiddleware(mux)
}
</code></pre>
<h2>Sending JSON responses</h2>
<p>JSON responses and a specific HTTP status code can be sent using the <code>response.JSON()</code> function. The <code>data</code> parameter can be any JSON-marshalable type.</p>
<pre><code>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    data := map[string]string{"hello":  "world"}

    err := response.JSON(w, http.StatusOK, data)
    if err != nil {
        app.serverError(w, r, err)
    }
}
</code></pre>
<p>Specific HTTP headers can optionally be sent with the response too:</p>
<pre><code>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    data := map[string]string{"hello":  "world"}

    headers := make(http.Header)
    headers.Set("X-Server", "Go")

    err := response.JSONWithHeaders(w, http.StatusOK, data, headers)
    if err != nil {
        app.serverError(w, r, err)
    }
}
</code></pre>
<h2>Parsing JSON requests</h2>
<p>HTTP requests containing a JSON body can be decoded using the <code>request.DecodeJSON()</code> function. For example, to decode JSON into an <code>input</code> struct:</p>
<pre><code>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    var input struct {
        Name string `json:"Name"`
        Age  int    `json:"Age"`
    }

    err := request.DecodeJSON(w, r, &amp;input)
    if err != nil {
        app.badRequest(w, r, err)
        return
    }
    
    ...
}
</code></pre>
<p>Note: The target decode destination passed to <code>request.DecodeJSON()</code> (which in the example above is <code>&amp;input</code>) must be a non-nil pointer.</p>
<p>The <code>request.DecodeJSON()</code> function returns friendly, well-formed, error messages that are suitable to be sent directly to the client using the <code>app.badRequest()</code> helper.</p>
<h2>Validating JSON requests</h2>
<p>The <code>internal/validator</code> package includes a simple (but powerful) <code>validator.Validator</code> type that you can use to carry out validation checks.</p>
<p>Extending the example above:</p>
<pre><code>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    var input struct {
        Name      string              `json:"Name"`
        Age       int                 `json:"Age"`
        Validator validator.Validator `json:"-"`
    }

    err := request.DecodeJSON(w, r, &amp;input)
    if err != nil {
        app.badRequest(w, r, err)
        return
    }

    input.Validator.CheckField(input.Name != "", "Name", "Name is required")
    input.Validator.CheckField(input.Age != 0, "Age", "Age is required")
    input.Validator.CheckField(input.Age &gt;= 21, "Age", "Age must be 21 or over")

    if input.Validator.HasErrors() {
        app.failedValidation(w, r, input.Validator)
        return
    }

    ...
}    
</code></pre>
<p>The <code>app.failedValidation()</code> helper will send a <code>422</code> status code along with any validation error messages. For the example above, the JSON response will look like this:</p>
<pre><code>
{
    "FieldErrors": {
        "Age": "Age must be 21 or over",
        "Name": "Name is required"
    }
}    
</code></pre>
<p>In the example above we use the <code>CheckField()</code> method to carry out validation checks for specific fields. You can also use the <code>Check()</code> method to carry out a validation check that is <em>not related to a specific field</em>. For example:</p>
<pre><code>
input.Validator.Check(input.Password == input.ConfirmPassword, "Passwords do not match")
</code></pre>
<p>The <code>validator.AddError()</code> and <code>validator.AddFieldError()</code> methods also let you add validation errors directly:</p>
<pre><code>
input.Validator.AddFieldError("Email", "This email address is already taken")
input.Validator.AddError("Passwords do not match")
</code></pre>
<p>The <code>internal/validator/helpers.go</code> file also contains some helper functions to simplify validations that are not simple comparison operations.</p>
<table>
<tbody>
<tr>
<td><code>NotBlank(value string)</code></td>
<td>Check that the value contains at least one non-whitespace character.</td>
</tr>
<tr>
<td><code>MinRunes(value string, n int)</code></td>
<td>Check that the value contains at least n runes.</td>
</tr>
<tr>
<td><code>MaxRunes(value string, n int)</code></td>
<td>Check that the value contains no more than n runes.</td>
</tr>
<tr>
<td><code>Between(value, min, max T)</code></td>
<td>Check that the value is between the min and max values inclusive.</td>
</tr>
<tr>
<td><code>Matches(value string, rx *regexp.Regexp)</code></td>
<td>Check that the value matches a specific regular expression.</td>
</tr>
<tr>
<td><code>In(value T, safelist ...T)</code></td>
<td>Check that a value is in a 'safelist' of specific values.</td>
</tr>
<tr>
<td><code>AllIn(values []T, safelist ...T)</code></td>
<td>Check that all values in a slice are in a 'safelist' of specific values.</td>
</tr>
<tr>
<td><code>NotIn(value T, blocklist ...T)</code></td>
<td>Check that the value is not in a 'blocklist' of specific values.</td>
</tr>
<tr>
<td><code>NoDuplicates(values []T)</code></td>
<td>Check that a slice does not contain any duplicate (repeated) values.</td>
</tr>
<tr>
<td><code>IsEmail(value string)</code></td>
<td>Check that the value has the formatting of a valid email address.</td>
</tr>
<tr>
<td><code>IsURL(value string)</code></td>
<td>Check that the value has the formatting of a valid URL.</td>
</tr>
</tbody>
</table>
<p>For example, to use the <code>Between</code> check your code would look similar to this:</p>
<pre><code>
input.Validator.CheckField(validator.Between(input.Age, 18, 30), "Age", "Age must between 18 and 30")
</code></pre>
<p>Feel free to add your own helper functions to the <code>internal/validator/helpers.go</code> file as necessary for your application.</p>
<h2>Logging</h2>
<p>The <code>internal/leveledlog</code> package provides a leveled-logger implementation. It outputs color-coded log lines in the following format:</p>
<pre><code>
level="INFO" time="2022-08-15T08:51:09+02:00" message="starting server on localhost:4444 (version 0.0.1)"
</code></pre>
<p>By default, a logger is initialized in the <code>main()</code> function which writes all log messages to <code>os.Stdout</code>. You can call the logger's <code>Info()</code>, <code>Warn()</code>, <code>Error()</code> and <code>Fatal()</code> methods to log messages at different levels with <code>fmt.Printf</code> style formatting. For example:</p>
<pre><code>
logger.Info("starting server on port %d", 1234)
</code></pre>
<p>Note: Stack traces are automatically appended to <code>Error()</code> and <code>Fatal()</code> messages, and calling <code>Fatal()</code> will cause your application to terminate.</p>
<p>If you want to disable the color-coding, then pass <code>false</code> as the final parameter when initializing the logger in <code>main()</code>.</p>
<pre><code>
logger := leveledlog.NewLogger(os.Stdout, leveledlog.LevelAll, false)
</code></pre>
<p>You can also write JSON-formated log entries instead by using the <code>NewJSONLogger()</code> function to initialize the logger:</p>
<pre><code>
logger := leveledlog.NewJSONLogger(os.Stdout, leveledlog.LevelAll)
</code></pre>
<p>Note: JSON-formatted log entries are not color-coded.</p>
<p>Feel free to adapt the <code>internal/leveledlog</code> package to change this behavior or include additional fields if you want.</p>
<h2>Admin tasks</h2>
<p>The <code>Makefile</code> in the project root contains commands to easily run common admin tasks:</p>
<table>
<tbody>
<tr>
<td><code>$ make tidy</code></td>
<td>Format all code using <code>go fmt</code> and tidy the <code>go.mod</code> file.</td>
</tr>
<tr>
<td><code>$ make audit</code></td>
<td>Run <code>go vet</code>, <code>staticheck</code>, execute all tests and verify required modules.</td>
</tr>
<tr>
<td><code>$ make build</code></td>
<td>Build a binary for the <code>cmd/api</code> application and store it in the <code>bin</code> folder.</td>
</tr>
<tr>
<td><code>$ make run</code></td>
<td>Build and then run a binary for the <code>cmd/api</code> application.</td>
</tr>
</tbody>
</table>
<h2>Application version</h2>
<p>The application version number is defined in a <code>Get()</code> function in the <code>internal/version/version.go</code> file. Feel free to change this as necessary.</p>
<pre><code>
package version

func Get() string {
    return "0.0.1"
}
</code></pre>
<h2>Changing the module path</h2>
<p>The module path is currently set to <code>example.com/jsonapi</code>. Please find and replace all instances of <code>example.com/jsonapi</code> in the codebase with your own module path.</p>
</div>
<!--------------------------------------------------------------------
Admin
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
HTTPS
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Module path
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Version
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Logging
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Database
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Config
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Web:Templates
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Web:Static
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Web:Forms
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
API:Sending
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
API:Decoding
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Funcs
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Validator
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Middleware
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Routing
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Handlers
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Structure
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Start
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Migrations
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Basic Auth
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Sessions
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
SMTP
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
ACCOUNTS (WEB)
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
ACCOUNTS (API)
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Cookies
------------------------------------------------------------------ -->
</body>
</html>
